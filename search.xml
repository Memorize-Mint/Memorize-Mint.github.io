<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1-5类型转换</title>
    <url>/2023/03/30/1-5%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p> Go强制要求使用显式类型转换，而且不支持操作符重载</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">a1 := <span class="number">10</span></span><br><span class="line">b1 := <span class="type">byte</span>(a1)</span><br><span class="line">c1 := a1 + <span class="type">int</span>(b1)	<span class="comment">//混合类型表达式必须保持一致</span></span><br></pre></td></tr></table></figure></div>

<p>不能将非bool类型结果当作true&#x2F;false</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">x2 := <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="type">bool</span> = x2	<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">if</span> x2 &#123;				<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果转换目标是指针类型、单项通道或没有返回值的函数类型，<br>那么必须使用括号，以避免造成语法分解的错误</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">p := (*<span class="type">int</span>)(&amp;x2)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;p: &quot;</span>, *p)</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>1-7未命名类型</title>
    <url>/2023/03/30/1-7%E6%9C%AA%E5%91%BD%E5%90%8D%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>与明确标识符的 bool int string 等类型相比，<br>数组，切片，字典，通道等类型与具体元素类型或长度等属性有关，<br>所以成为未命名类型 ( unname  2_type)，<br>当然，可用type为其提供具体名称，<br>将其改变为命名变量 (name  2_type)</p>
<p><strong>具有相同声明的未命名类型被视作统一的类型:</strong></p>
<ul>
<li>具有相同基类型指针</li>
</ul>
<ul>
<li>具有相同元素类型和长度的数组（array）</li>
<li>具有相同元素类型的切片（slice）</li>
<li>具有相同键值类型的字典（map）</li>
<li>具有相同数据类型及操作方向的通道（channel）</li>
<li>具有相同字段序列（字段名、字段类型、标签、以及字段顺序）的结构体（struct）</li>
<li>具有相同签名（参数和返回值列表，不包括参数名）的函数（func）</li>
<li>具有相同方法集（方法名，方法签名，不包括顺序）的接口（interface）</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>1-4引用类型</title>
    <url>/2023/03/30/1-4%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>所谓引用类型特指slice、map、channel这三种预定义类型。</p>
<p>拥有更复杂的存储结构，除了分配内存外，它们还须初始化一些了属性，</p>
<p>诸如指针、长度、甚至包括哈希分布】数据队列等。</p>
<p>内置函数<strong>new</strong>按指定类型长度分配0值内存，返回指针，并不关系你类型内部构造和初始化方式。</p>
<p>而引用类型则必须使用<strong>make</strong>函数创建，编译器会将转换为目标类型专用的创造函数(或指令)，以确保完成全部内存分配和相关属性初始化。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mkslice</span><span class="params">()</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mkmap</span><span class="params">()</span></span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    m[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)	<span class="comment">//函数new返回指针</span></span><br><span class="line">    m := *p</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>虽然new函数为引用类型分配内存，但是是不完整创建。</p>
<p>仅分配了所需内存用指针包装，并没有分配键值存储内存，也没有初始化散列桶等内部属性，无法正常工作。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>1-2常量</title>
    <url>/2023/03/30/1-2%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<p> 常量的定义与变量的定义类似:</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x1, y1 <span class="type">int</span> = <span class="number">123</span>, <span class="number">0x22</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	i, f = <span class="number">1</span>, <span class="number">0.123</span>		<span class="comment">//int, float(默认)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>可在代码块中定义常量，不曾使用的常量不会引发编译错误</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> x =<span class="number">123</span></span><br><span class="line">    <span class="built_in">println</span>(x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> y = <span class="number">1.23</span>		<span class="comment">//未使用不会引发编译错误</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> x = <span class="string">&quot;abc&quot;</span>		<span class="comment">//在不同作用域定义同名变量</span></span><br><span class="line">        <span class="built_in">println</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure></div>

<p>如果显式指定类型，必须确保常量左右值类型一致，需要时可做显式转换，<br>右键不能超出常量类型取值范围，否则会引发溢出错</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   x, k <span class="type">int</span>  = <span class="number">99</span>, <span class="number">-999</span></span><br><span class="line">   b    <span class="type">byte</span> = <span class="type">byte</span>(x)</span><br><span class="line">   <span class="comment">//x 为int类型，须显式转换byte类型</span></span><br><span class="line">   <span class="comment">//n = unit8(y)  错误  -999 overflows unit8</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>常量也可以是某些编译器能计算出结果的表达式</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   ptrSize = unsafe.Sizeof(<span class="type">uintptr</span>(<span class="number">0</span>))</span><br><span class="line">   strSize = <span class="built_in">len</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">   <span class="comment">//uintptr 是 uint8 的别名，在所有方面都等效于 uint8。</span></span><br><span class="line">   <span class="comment">//按照惯例，它用于区分字节值和 8 位无符号整数值。</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;ptrSize: &quot;</span>, ptrSize) 	<span class="comment">//8</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;strSize: &quot;</span>, strSize) 	<span class="comment">//11</span></span><br></pre></td></tr></table></figure></div>

<p>在常量组中如果不指定类型和初始值，<br>则与上一行非空常值右值(表达式文本)相同</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   x2 <span class="type">uint16</span> = <span class="number">120</span></span><br><span class="line">   y2</span><br><span class="line">   s2 = <span class="string">&quot;abc&quot;</span></span><br><span class="line">   z2</span><br><span class="line">)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T,%v\n&quot;</span>, y2, y2) 	<span class="comment">//uint16,120</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T,%v\n&quot;</span>, z2, z2) 	<span class="comment">//string,abc</span></span><br></pre></td></tr></table></figure></div>

<p>常量除了只读外，不同于变量可以定义运行期分配储存内存<br>常量通常会被编译器在预处理阶段直接展开，作为指令数据使用。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>1-1变量</title>
    <url>/2023/03/30/1-1%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Go使用关键字var定义变量，与传统编程语言C和Java定义变量不同，Go则将类型放置变量名之后。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int</span>			<span class="comment">//自动初始化为0</span></span><br><span class="line"><span class="keyword">var</span> y = flase 		<span class="comment">//自动推断为bool类型</span></span><br></pre></td></tr></table></figure></div>

<p>也可一次定义多个变量，包括不同初始值定义不同类型</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span>		<span class="comment">//相同类型的多个变量</span></span><br><span class="line"><span class="keyword">var</span> a, s = <span class="number">100</span>, <span class="string">&quot;abc&quot;</span>		<span class="comment">//不同类型的初始化值</span></span><br></pre></td></tr></table></figure></div>

<p>不过依照简便和可读性，也可以按组的方式多行变量定义</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">    x, y <span class="type">int</span></span><br><span class="line">    a,s = <span class="number">100</span>, <span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="简短模式"><a href="#简短模式" class="headerlink" title="简短模式"></a>简短模式</h2><p>其实除了使用var关键字还可以使用一种更简单的变量定义和初始化语法的方法。如下：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">100</span></span><br><span class="line">    a, s := <span class="number">1</span>, <span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不过需要注意的是，简短模式虽然看似定义简单，但是也有一些<strong>限制</strong>：</p>
<ul>
<li>定义变量，同时显式初始化</li>
<li>不能提供数据类型</li>
<li>只能用在函数内部</li>
</ul>
<p>要记住，简短模式是快速定义一个新变量的方法，<strong>而不是修改变量值的方法</strong>。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> k = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(&amp;k, k)</span><br><span class="line">    k := <span class="string">&quot;200&quot;</span>		<span class="comment">//重新定义和初始化同名局部变量</span></span><br><span class="line">    <span class="built_in">println</span>(&amp;k, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0x4c5248</span> <span class="number">100</span>		<span class="comment">//对比内存地址，看出是两个不同的变量</span></span><br><span class="line"><span class="number">0xc000069f68</span> <span class="number">200</span></span><br></pre></td></tr></table></figure></div>

<p>但是，简短模式并不总是重新定义变量的，也可能是部分退化的赋值操作</p>
<p>前提条件是：最少有一个变量被定义，并且必须在同一个作用域</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	k := <span class="number">32</span> <span class="comment">//定义变量简短模式</span></span><br><span class="line">	<span class="built_in">println</span>(&amp;k, k)</span><br><span class="line"></span><br><span class="line">	k, j := <span class="number">200</span>, <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="comment">//k := 200	报错: no new variable on left side of :=</span></span><br><span class="line">	<span class="built_in">println</span>(&amp;k, k)</span><br><span class="line">	<span class="built_in">println</span>(j)</span><br><span class="line">    </span><br><span class="line">    &#123; <span class="comment">//不同作用域，全部视作是新变量定义</span></span><br><span class="line">		k, j := <span class="number">300</span>, <span class="number">300</span></span><br><span class="line">		<span class="built_in">println</span>(&amp;k, k, j)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>输出</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0xc000069f68</span> <span class="number">32</span></span><br><span class="line"><span class="number">0xc000069f68</span> <span class="number">200</span></span><br><span class="line">abc</span><br><span class="line"><span class="number">0xc000069f60</span> <span class="number">300</span> <span class="number">300</span></span><br></pre></td></tr></table></figure></div>

<h2 id="多变量赋值"><a href="#多变量赋值" class="headerlink" title="多变量赋值"></a>多变量赋值</h2><p>在进行错变量赋值时，首先计算出所有右值，然后再依次完成赋值操作。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//多变量赋值</span></span><br><span class="line">	a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">	a, b = b+<span class="number">3</span>, a+<span class="number">2</span></span><br><span class="line">	<span class="built_in">println</span>(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<h2 id="未使用错误"><a href="#未使用错误" class="headerlink" title="未使用错误"></a>未使用错误</h2><p>顾名思义，编译器将创建的并且未使用的<strong>局部变量</strong>当作错误，但是全局变量不做规范。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>2-3初始化</title>
    <url>/2023/04/03/2-3%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对复合类型（数组、切片、字典、结构体）变量初始化时，有一些语法限制</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   初始化表达式必须包含类型标签</span></span><br><span class="line"><span class="comment">   左花括号必须在类型尾部，不能另起一行</span></span><br><span class="line"><span class="comment">   多个成员初始值以逗号分割</span></span><br><span class="line"><span class="comment">   允许多行，但每行须以逗号或右花括号结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">      x <span class="type">int</span></span><br><span class="line">      s <span class="type">string</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> a data = data&#123;<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>&#125;</span><br><span class="line">	<span class="comment">//注意看逗号 ,</span></span><br><span class="line">   b := data&#123;</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   c := []<span class="type">int</span>&#123;</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span>&#125;</span><br><span class="line">   d := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">      <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">      <span class="number">5</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">println</span>(a, b, c, d) <span class="comment">//这样并不能输出只是为了程序存放不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>1-3枚举</title>
    <url>/2023/03/30/1-3%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>由于以后的案例可能会经常运用到枚举，</p>
<p>所以提前带大家了解iota标识符。</p>
<p>首先，Go语言中没有对enum的定义</p>
<p>但是我们可以借助iota标识符实现一组自增变量值来实现枚举举例</p>
<h2 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h2><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    AA = <span class="literal">iota</span>  	<span class="comment">//0</span></span><br><span class="line">    BB       	<span class="comment">//1</span></span><br><span class="line">   	CC       	<span class="comment">//2</span></span><br><span class="line">    DD = <span class="literal">iota</span> + <span class="number">1</span>  	<span class="comment">//3 + 1 = 4</span></span><br><span class="line">    EE       		<span class="comment">//EE=5 没有重新定义iota 所以按照DD依次加一</span></span><br><span class="line">   )</span><br></pre></td></tr></table></figure></div>

<p>通过案例1，我们可以认识到iota标识符的使用。</p>
<p>没有赋值的变量被标识iota后，默认初始值为0，</p>
<p>下面的变量不必标识出来也会依次自增一</p>
<h2 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h2><p>理解上述关系，下面列举案例二</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   	AA = <span class="literal">iota</span> &lt;br&gt;	<span class="comment">//0</span></span><br><span class="line">   	BB</span><br><span class="line">    CC</span><br><span class="line">   	DD = <span class="literal">iota</span> + <span class="number">1</span>   <span class="comment">//4</span></span><br><span class="line">   	EE            	<span class="comment">//5</span></span><br><span class="line">    FF = <span class="literal">iota</span> + <span class="number">2</span></span><br><span class="line">            <span class="comment">//FF = 7 这里是因为每次有变量声明iota标识符时，</span></span><br><span class="line">            <span class="comment">//将会从第一个被标识iota的变量开始计数，</span></span><br><span class="line">            <span class="comment">//并不会受到途中其他加减变量的影响。</span></span><br><span class="line">            <span class="comment">// 5 + 2 = 7</span></span><br><span class="line">    GG = <span class="literal">iota</span></span><br><span class="line">            <span class="comment">//GG = 6 这里由于GG重新声明了iota</span></span><br><span class="line">            <span class="comment">//所以又从第一次声明iota的位置枚举</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h2 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h2><p>下面通过案例三认识新的iota性质</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   AA, BB = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span>  <span class="comment">//AA=1,BB=2</span></span><br><span class="line">   CC, DD 						<span class="comment">//CC=1,DD=1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>iota的一个重要性质就是<strong>按照行枚举</strong>，也就是每行加一<br>所以第一行为 0 其他就依次可解决。</p>
<p>但是我们常常使用枚举，不仅需要定义其各自变量的值，还可能需要描述信息<br>这时我们可以使用map映射达到如java的枚举效果</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ColorMap = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;</span><br><span class="line">      ColorRed:       <span class="string">&quot;赤&quot;</span>,</span><br><span class="line">      ColorOrange:    <span class="string">&quot;橙&quot;</span>,</span><br><span class="line">      ColorYellow:    <span class="string">&quot;黄&quot;</span>,</span><br><span class="line">      ColorGrassland: <span class="string">&quot;绿&quot;</span>,</span><br><span class="line">      ColorCyan:      <span class="string">&quot;青&quot;</span>,</span><br><span class="line">      ColorBlue:      <span class="string">&quot;蓝&quot;</span>,</span><br><span class="line">      ColorPurple:    <span class="string">&quot;紫&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="案例4"><a href="#案例4" class="headerlink" title="案例4"></a>案例4</h2><p>iota默认自增类型为int类型，</p>
<p>也可以手动更改显式指定类型，如：float</p>
<p>如果更改显式类型，下面的变量即使不声明iota和显式类型，也会和最近的那个iota显式类型保持一致。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   a         = <span class="literal">iota</span> 	<span class="comment">//int (默认自增为 int 类型)</span></span><br><span class="line">   b <span class="type">float32</span> = <span class="literal">iota</span> 	<span class="comment">//float32 (可显式指定类型)</span></span><br><span class="line">   c         = <span class="literal">iota</span> 	<span class="comment">//int(如不显式指定iota,则与b数据类型相同)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h2 id="案例5"><a href="#案例5" class="headerlink" title="案例5"></a>案例5</h2><p>如果中断iota自增，</p>
<p>则必须显式恢复，后续自增序按照行序递增</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   a1 = <span class="literal">iota</span> 	<span class="comment">//0</span></span><br><span class="line">   b2</span><br><span class="line">   c2 = <span class="number">100</span> 	<span class="comment">//100</span></span><br><span class="line">   d        	<span class="comment">//100 (与上一行常量右值表达式相同)</span></span><br><span class="line">   e			<span class="comment">//100</span></span><br><span class="line">   f = <span class="literal">iota</span> 	<span class="comment">//恢复自增，计数包括c,d,e; f = 5</span></span><br><span class="line">   g			<span class="comment">// g = 6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>2-2运算符</title>
    <url>/2023/04/03/2-2%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h2><p>操作类型必须相同，如果声明了一个无显示类型的常量，那么该常量操作数会自动转型。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> v = <span class="number">20</span>	<span class="comment">// 无显式类型声明的常量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> a <span class="type">byte</span> = <span class="number">10</span></span><br><span class="line">    b := v + a		<span class="comment">// v自动转换为 byte/uint8类型</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T, %v\n&quot;</span>, b, b)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> c <span class="type">float32</span> = <span class="number">1.2</span></span><br><span class="line">    d := c + v		<span class="comment">// v自动转换为 float32类型</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T, %v\n&quot;</span>, d, d)		<span class="comment">//%v：会以默认形式打印值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出:</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8</span>, <span class="number">30</span></span><br><span class="line"><span class="type">float32</span>, <span class="number">21.2</span></span><br></pre></td></tr></table></figure></div>

<p>右移位操作数必须是无符号整数，或可以转换的无显示类型常量</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := <span class="number">23</span>      <span class="comment">//有符号int类型变量</span></span><br><span class="line">	x4 := <span class="number">1</span> &lt;&lt; v1 <span class="comment">//无效操作</span></span><br><span class="line">	<span class="built_in">println</span>(x4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果是非常量位移表达式，那么会优先将无显示类型的常量左操作数转型。 </p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a3 := <span class="number">1.0</span> &lt;&lt; <span class="number">3</span>                <span class="comment">//常量表达式（包括常量展开）</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%v\n&quot;</span>, a3, a3) <span class="comment">//int,8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		read   <span class="type">byte</span> = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">//00000001 = 1</span></span><br><span class="line">		write                   <span class="comment">//00000010 = 2</span></span><br><span class="line">		exec                    <span class="comment">//00000100 = 4</span></span><br><span class="line">		freeze                  <span class="comment">//00001000 = 8</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := read | write | freeze <span class="comment">//1011</span></span><br><span class="line">	b := read | freeze | exec <span class="comment">//1101</span></span><br><span class="line">	c := a &amp;^ b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%04b &amp;^ %04b = %04b\n&quot;</span>, a, b, c)</span><br><span class="line">    <span class="comment">//1011 &amp;^ 1101 = 0010</span></span><br><span class="line">	<span class="comment">// &amp;^ b 的意思就是 将b中为1的位 对应于a的位比较后，</span></span><br><span class="line">    <span class="comment">// 如果a,b同位都为1，则清0，</span></span><br><span class="line">	<span class="comment">//若b中位0的位 对应 a中1位，则a位不变，其他位不变。</span></span><br><span class="line">	<span class="comment">//功能同a&amp;(^b)相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h2><p>自增自减不再是运算符，只能作为独立语句，<strong>不能用于表达式</strong></p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="number">1</span>	<span class="comment">// ++m   //语法错误  不能前置</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	if (m++) &gt; 1 &#123;  语法错误 不能作为表达式使用</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">p := &amp;m</span><br><span class="line">*p++ 		<span class="comment">//相当于 （*p）++</span></span><br><span class="line"><span class="built_in">println</span>(m)	<span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>不能将内存地址与指针混为一谈<br>内存地址是内存中每个字节单元的唯一编号，<br>而指针则是一个实体。指针会分配内存空间，<br>相当于一个专门用来保存地址的整体变量，并非所有对象都可以进行地址操作<br><strong>指针运算符为左值时，我们可以更新目标对象状态<br>为右值时则是为了获取目标状态</strong></p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> p *<span class="type">int</span> = &amp;x 	<span class="comment">//获取地址，保存到指针变量</span></span><br><span class="line">    *p += <span class="number">20</span>         <span class="comment">//用指针间接引用，并更新对象</span></span><br><span class="line">	<span class="built_in">println</span>(p, *p)  <span class="comment">//输出指针所存储的地址，以及目标对象</span></span><br><span class="line">    <span class="comment">// p = 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果两个指针指向同一地址，或都为nil，那他们相等<br>指针没有专门指向成员的“-&gt;”运算符，<strong>统一使用”.”选择表达式</strong></p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := <span class="keyword">struct</span> &#123;</span><br><span class="line">		x <span class="type">int</span></span><br><span class="line">	&#125;&#123;&#125;</span><br><span class="line">	f.x = <span class="number">10</span></span><br><span class="line">	a := &amp;f</span><br><span class="line">	a.x += <span class="number">100</span></span><br><span class="line">	<span class="built_in">println</span>(a.x)	<span class="comment">//110</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>零长度对象的地址是否相等和具体的实现版本有关，不过肯定不等于nil</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ma, mi <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">		<span class="comment">//即使长度为0，依旧合法存在，拥有合法地址，与nil语义不同</span></span><br><span class="line"><span class="built_in">println</span>(&amp;ma, &amp;mi)</span><br><span class="line"><span class="built_in">println</span>(&amp;ma == &amp;mi, &amp;ma == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></div>

<p>输出:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xc000129eb0 0xc000129eb0</span><br><span class="line">false false		//有些版本可能是 true false</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>3-1init函数</title>
    <url>/2023/04/03/3-1init%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* init函数的主要特点：</span></span><br><span class="line"><span class="comment">* init函数先于main函数自动执行，不能被其他函数调用；</span></span><br><span class="line"><span class="comment">* init函数没有输入参数、返回值；</span></span><br><span class="line"><span class="comment">* 每个包可以有多个init函数；</span></span><br><span class="line"><span class="comment">* 包的每个源文件也可以有多个init函数，这点比较特殊；</span></span><br><span class="line"><span class="comment">* 同一个包的init执行顺序，golang没有明确定义，编程时要注意程序不要依赖这个执行顺	序。</span></span><br><span class="line"><span class="comment">* 同一个包的不同源文件的init函数执行顺序时该源文件名称的字典库</span></span><br><span class="line"><span class="comment">* 不同包的init函数按照包导入的依赖关系决定执行顺序。</span></span><br><span class="line"><span class="comment">* init函数不可以被调用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p><strong>补充go的程序初始化</strong><br>golang程序初始化先于main函数执行，由runtime进行初始化，初始化顺序如下：</p>
<ol>
<li><p>初始化导入的包（包的初始化顺序<strong>并不是</strong>按导入顺序（“从上到下”）执行的，runtime需要解析包依赖关系，没有依赖的包最先初始化，与变量初始化依赖关系类似，参见golang变量的初始化）；</p>
</li>
<li><p>初始化包作用域的变量（该作用域的变量的初始化也并非按照“从上到下、从左到右”的顺序，runtime解析变量依赖关系，没有依赖的变量最先初始化，参见golang变量的初始化）；</p>
</li>
<li><p>执行包的init函数</p>
</li>
</ol>
<p>具体参考该网址<a class="link"   href="https://zhuanlan.zhihu.com/p/34211611%E7%90%86%E8%A7%A3%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F" >https://zhuanlan.zhihu.com/p/34211611理解调用顺序 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>2-4控制流语句</title>
    <url>/2023/04/03/2-4%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p> 按照雨痕大大的原话说：</p>
<p>Go精简了流控制语句，某些时候不够便捷，但够用。</p>
<h2 id="if…else…"><a href="#if…else…" class="headerlink" title="if…else…"></a>if…else…</h2><p>条件表达式值必须是布尔类型，可省略括号，且左花括号不能另起一行。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">3</span></span><br><span class="line">	<span class="keyword">if</span> x &gt; <span class="number">5</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> x &lt; <span class="number">5</span> &amp;&amp; x &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;z&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>与if类似，switch语句也用于选择执行，但具体使用场景会有所不同</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">7</span></span><br><span class="line">    <span class="keyword">switch</span> x &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>, y: 			<span class="comment">//多个匹配条件命中其一即可(OR)变量</span></span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>:			<span class="comment">//常量</span></span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;d&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;e&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> a: 	<span class="comment">//单条件，内容为空不构成多条件匹配，隐式&quot;case a: break;&quot;</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>无需显示break语句，case执行完毕后自动中断，如需贯通后续case（源码顺序），</p>
<p>需要执行fallthrough，但不再匹配后续条件表达式.</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;The integer was &lt;= 4&quot;</span>)</span><br><span class="line">		<span class="keyword">fallthrough</span>			<span class="comment">//继续执行下一case，但不再匹配条件表达式</span></span><br><span class="line">	<span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;The integer was &lt;= 5&quot;</span>)</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;The integer was &lt;= 6&quot;</span>)</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;The integer was &lt;= 7&quot;</span>)</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;The integer was &lt;= 8&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;default case&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">result:</span><br><span class="line">		The integer was &lt;= <span class="number">5</span></span><br><span class="line">		The integer was &lt;= <span class="number">6</span></span><br><span class="line">		The integer was &lt;= <span class="number">7</span></span><br><span class="line">		The integer was &lt;= <span class="number">8</span></span><br></pre></td></tr></table></figure></div>

<p>fallthrough必须放在case快的结尾，可使用break提前阻止。</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">&#125;</span><br><span class="line">x := <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> x &lt; <span class="number">20</span> &#123; 		<span class="comment">//类似while x &lt; 20 &#123;&#125; 或 for ; x&lt;20; &#123;&#125;</span></span><br><span class="line">   x++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123; 		<span class="comment">//类似while true&#123;&#125; 或者 for true &#123;&#125;</span></span><br><span class="line">   <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>初始化语句仅被执行一次，条件表达式中如果有函数调用，<br>需要确认是否重复执行，可能会被编译器优化掉，也可能是动态结果须每次执行确认.</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, c := <span class="number">0</span>, count(); i &lt; c; i++ &#123; <span class="comment">//初始化语句count仅被执行一次</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;a&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c &lt; count() &#123; <span class="comment">//条件表达式中的count重复执行</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>, c)</span><br><span class="line">	c++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可用for…range 完成数据迭代</p>
<p>支持字符串、数组、数组指针、切片、通道类型、返回索引、键值数据</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    data := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i, s := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="built_in">println</span>(i, s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>允许返回单值，或者用 “_” 忽略</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> data &#123; 		<span class="comment">//只返回 1st value</span></span><br><span class="line">		<span class="built_in">println</span>(i, data[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> data &#123; 	<span class="comment">//忽略 1st value</span></span><br><span class="line">		<span class="built_in">println</span>(s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//无论是for循环还是range迭代，其定义的局部变量都会重复使用</span></span><br><span class="line">	<span class="keyword">for</span> i, s := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="built_in">println</span>(&amp;i, &amp;s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> a</span><br><span class="line"><span class="number">1</span> b</span><br><span class="line"><span class="number">2</span> c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure></div>

<p>注意range会复制目标数据，受直接影响的是数组，可改用数组指针或切片类型</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i, x := <span class="keyword">range</span> data &#123; 	<span class="comment">//从data 复制品中取值</span></span><br><span class="line">   		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">      		data[<span class="number">0</span>] += <span class="number">100</span></span><br><span class="line">      		data[<span class="number">1</span>] += <span class="number">200</span></span><br><span class="line">      		data[<span class="number">2</span>] += <span class="number">300</span></span><br><span class="line">   		&#125;</span><br><span class="line">   	fmt.Printf(<span class="string">&quot;x: %d, data: %d\n&quot;</span>, x, data[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">x: <span class="number">10</span>, data: <span class="number">110</span></span><br><span class="line">x: <span class="number">20</span>, data: <span class="number">220</span></span><br><span class="line">x: <span class="number">30</span>, data: <span class="number">330</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> data[:] &#123; <span class="comment">//仅复制slice 不包括底层 array</span></span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">		data[<span class="number">0</span>] += <span class="number">100</span></span><br><span class="line">		data[<span class="number">1</span>] += <span class="number">200</span></span><br><span class="line">		data[<span class="number">2</span>] += <span class="number">300</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;x: %d, data: %d\n&quot;</span>, x, data[i])</span><br><span class="line">	<span class="comment">//当 i==0 修改data时,x已经取值，所以 x是10，data是 110</span></span><br><span class="line">	<span class="comment">//复制的仅是 slice本身 底层 array 仍然是原对象</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> data1[:] &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;data: %d\n&quot;</span>, data1[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">x: <span class="number">10</span>, data: <span class="number">110</span></span><br><span class="line">x: <span class="number">220</span>, data: <span class="number">220</span></span><br><span class="line">x: <span class="number">330</span>, data: <span class="number">330</span></span><br><span class="line">data: <span class="number">110</span></span><br><span class="line">data: <span class="number">220</span></span><br><span class="line">data: <span class="number">330</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>如果range目标表达式是函数调用，也仅被执行一次</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">data</span><span class="params">()</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;origin data.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> data() &#123;</span><br><span class="line">   		<span class="built_in">println</span>(i, x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">origin data.</span><br><span class="line"><span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">30</span></span><br></pre></td></tr></table></figure></div>

<h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>使用goto前，需要先定义标签，标签区分大小写，且未使用的标签会引发编译错误</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start:   <span class="comment">//错误， 标签start确定没被使用</span></span><br><span class="line"> 		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">	    	<span class="keyword">if</span> i &gt; <span class="number">1</span> &#123;</span><br><span class="line">	       		<span class="keyword">goto</span> exit</span><br><span class="line">	    	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	exit:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;exit...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不能跳转到其他函数，或是内层代码块内</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">test:</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;test exit.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">	loop:</span><br><span class="line">		<span class="built_in">println</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> test       <span class="comment">//错误: label tesr not defined</span></span><br><span class="line">	<span class="keyword">goto</span> loop       <span class="comment">//错误: goto loop jumps into block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>和goto 定点跳转不同，break、continue用于中断代码块执行,</p>
<p>介于在go中break与continue的使用与其他语言几乎无差别，所以不做多赘述。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>3-2函数定义</title>
    <url>/2023/04/04/3-2%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h2 id="go函数定义的一些限制或优点"><a href="#go函数定义的一些限制或优点" class="headerlink" title="go函数定义的一些限制或优点"></a>go函数定义的一些限制或优点</h2><ul>
<li><p>无须前置声明</p>
</li>
<li><p>不支持命名嵌套定义</p>
</li>
<li><p>不支持同名函数重载</p>
</li>
<li><p>不支持默认参数</p>
  <div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y, <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x+y</span><br><span class="line">&#125;  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>支持不定长变参</p>
</li>
<li><p>支持多返回值</p>
</li>
<li><p>支持命名返回值</p>
</li>
<li><p>支持匿名函数和闭包</p>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数属于第一类对象，具备相同签名(参数及返回值列表)的视为同一类型</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exec</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := hello</span><br><span class="line">	exec(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里解释一下何为第一类对象</span></span><br><span class="line"><span class="comment">    在计算机科学中指可以在执行期创造并作为参数传递给其他函数或存入一个变量的		实体。</span></span><br><span class="line"><span class="comment">    将一个实体变为第一类对象的过程叫做“物件化”</span></span><br><span class="line"><span class="comment">    第一类对象不一定是面向对象程序设计所指的物件，</span></span><br><span class="line"><span class="comment">    而可以指任何程序中的实体。一般第一类对象所特有的特性为：</span></span><br><span class="line"><span class="comment">    * 可以被存入变量或其他结构</span></span><br><span class="line"><span class="comment">    * 可以被作为参数传递给其他函数</span></span><br><span class="line"><span class="comment">    * 可以被作为函数的返回值</span></span><br><span class="line"><span class="comment">    * 可以在执行期创造，而无需完全在设计期全部写出</span></span><br><span class="line"><span class="comment">    * 即使没有被系结至某一名称，也可以存在</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p>函数只能判断其是否为nil，不支持其他比较操作</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(a == <span class="literal">nil</span>)	<span class="comment">//false</span></span><br><span class="line">    <span class="built_in">println</span>(b == a)</span><br><span class="line">	<span class="comment">//invalid operation: b == a (func can only be compared to nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>3-3参数</title>
    <url>/2023/04/04/3-3%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ul>
<li><p>不支持有默认值的可选参数，</p>
</li>
<li><p>不支持命名实参。</p>
</li>
<li><p>调用时，必须按照签名顺序传递指定类型和数量的实参，</p>
</li>
<li><p>就算以”_”命名的参数也不能忽略</p>
</li>
<li><p>相邻同类型参数可合并</p>
</li>
</ul>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="type">int</span>, s <span class="type">string</span>, _ <span class="type">bool</span>)</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;abc&quot;</span>)		<span class="comment">//错误:传参数量不足</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>参数可视作函数局部变量，因此不能在相同层次定义同名变量</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   x := <span class="number">100</span>   		<span class="comment">// 错误: no new variables on left side of :=</span></span><br><span class="line">   <span class="keyword">var</span> y <span class="type">int</span>  		<span class="comment">// 错误: y redeclared in this block</span></span><br><span class="line">   <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="形参-amp-实参"><a href="#形参-amp-实参" class="headerlink" title="形参&amp;实参"></a>形参&amp;实参</h2><p>形参是指函数定义中的参数，实参是指函数调用时所传递的参数<br>形参类似函数局部变量,而实参是函数外部对象</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>无论时什么类型，参数都是值拷贝传递，区别无非是拷贝目标对象<br>还是拷贝指针而已。在函数调用前，<br>会为形参和返回值分配内存空间，并将实参拷贝到形参内存。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(x *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;pointer: %p, target: %v\n&quot;</span>, &amp;x, x)</span><br><span class="line">   <span class="comment">//输出形参x的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">0x100</span></span><br><span class="line">	p := &amp;a</span><br><span class="line">	fmt.Printf(<span class="string">&quot;pointer: %p, target: %v\n&quot;</span>, &amp;p, p)</span><br><span class="line">	<span class="comment">//输出实参p的地址</span></span><br><span class="line">	test1(p)</span><br><span class="line">	<span class="comment">//结果看出，尽管实参形参都指向同一目标，但传递指针时依然被复刻</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出:</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">pointer: <span class="number">0xc00000a028</span>, target: <span class="number">0xc0000160c8</span></span><br><span class="line">pointer: <span class="number">0xc00000a038</span>, target: <span class="number">0xc0000160c8</span></span><br></pre></td></tr></table></figure></div>

<h2 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h2><p>变参本质就是一个切片，只能接收一个或多个同类型参数，且必须放在列表末尾</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s <span class="type">string</span>, a ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%T, %v\n&quot;</span>, a, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test(<span class="string">&quot;abc&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) 	<span class="comment">//[]int, [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>将切片作为参数时，须进行展开操作。如果是数组，先将其转换为切片</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">    test(a[:]...)		<span class="comment">//转换为 slice后展开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>即使变参是切片、那么参数复制的仅仅是切片本身，<br>并不包括底层数组，也因此可修改原数据<br>如果需要，可用内置函数copy复制底层数据</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">      a[i] += <span class="number">100</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">	test(a...)</span><br><span class="line"></span><br><span class="line">	fmt.Println(a) 		<span class="comment">//[110 120 130]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>1-6自定义类型</title>
    <url>/2023/03/30/1-6%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p> 使用type关键字定义用户自定义类型，包括基于现有基础类型创建，或是结构体、函数类型等。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> flags <span class="type">byte</span></span><br><span class="line"><span class="keyword">type</span> ( <span class="comment">//组</span></span><br><span class="line">   user <span class="keyword">struct</span> &#123; <span class="comment">//结构体</span></span><br><span class="line">      name <span class="type">string</span></span><br><span class="line">      age  <span class="type">int</span></span><br><span class="line">   &#125;</span><br><span class="line">   event <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">bool</span> <span class="comment">//函数类型</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>即便指定了相同的基础类型，也只能表明他们拥有相同的底层数据类型结构，<br>二者不存在任何关系，属于完全不用的类型。<br>自定义类型不会继承基础类型的其他信息，包括方法，不能视为别名<br>不能隐式转换，不能直接用于比较表达式</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> d data = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span> = d   <span class="comment">//错误</span></span><br><span class="line"><span class="built_in">println</span>(x)</span><br><span class="line"><span class="built_in">println</span>(d == x)  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></div>

<p>最后介绍位掩码</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   <span class="comment">//位掩码表达式      		移动位数</span></span><br><span class="line">   read  flags = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 1 &lt;&lt; 0 00000001</span></span><br><span class="line">   write                   <span class="comment">// 1 &lt;&lt; 1 00000010</span></span><br><span class="line">   exec                    <span class="comment">// 1 &lt;&lt; 2 00000100</span></span><br><span class="line">   eee                     <span class="comment">// 1 &lt;&lt; 3 00001000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>2-1保留字</title>
    <url>/2023/04/03/2-1%E4%BF%9D%E7%95%99%E5%AD%97/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Go语言保留字仅25个，相比其他语言简洁不少。</p>
<p>包管理（2个）：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>	 <span class="keyword">package</span> </span><br></pre></td></tr></table></figure></div>

<p>程序实体声明与定义（8个）： </p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chan</span>	<span class="keyword">const</span>	<span class="function"><span class="keyword">func</span>	<span class="title">interface</span>	<span class="title">map</span>	 <span class="title">struct</span>	 <span class="title">type</span>  <span class="title">var</span></span> </span><br></pre></td></tr></table></figure></div>

<p>程序流程控制（15个）： break	case	continue	default	defer	else	fallthrough	 for		go		goto		if		range	return	select		switch</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>	<span class="keyword">case</span>	<span class="keyword">continue</span>	<span class="keyword">default</span>		<span class="keyword">defer</span>	<span class="keyword">else</span>	<span class="keyword">fallthrough</span>	 <span class="keyword">for</span>	<span class="keyword">go</span>		<span class="keyword">goto</span>		<span class="keyword">if</span>		<span class="keyword">range</span>	<span class="keyword">return</span>	<span class="keyword">select</span>		<span class="keyword">switch</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>3-4返回值</title>
    <url>/2023/04/04/3-5%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<p>有返回值的函数，必须有明确的return终止语句</p>
<p>除非有panic或者无break的死循环，则无须return终止语句</p>
<h2 id="多返回值模式"><a href="#多返回值模式" class="headerlink" title="多返回值模式"></a>多返回值模式</h2><p>借鉴自动态语言的多返回值模式，函数得以返回更多形态，以error举例</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(x, y <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> y == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;division by zero&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x / y, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(x <span class="type">int</span>, err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(x, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">text</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> div(<span class="number">5</span>, <span class="number">0</span>) <span class="comment">//多返回值做return结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log(text()) <span class="comment">//多返回值用作实参</span></span><br><span class="line">	<span class="comment">// 0 division by zero</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h2><p>对返回值命名和简短变量定义一样，优缺点并存。</p>
<p>命名返回值和参数一样，可作为函数局部变量使用，最后又return隐式返回。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(x, y <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> y == <span class="number">0</span> &#123;</span><br><span class="line">        err = errors.New(<span class="string">&quot;division by zero&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	z = x / y</span><br><span class="line">    <span class="keyword">return</span>		<span class="comment">//相当与 return z, err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这些”局部变量“会被不同层级的同名变量遮蔽，好在编译器会检查到这种情况，</p>
<p>只要改为显式return返回即可。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		z := x + y			<span class="comment">//新定义的同名局部变量，同名遮蔽</span></span><br><span class="line">		<span class="keyword">return</span>				<span class="comment">//改为 return z即可</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>3-5匿名函数</title>
    <url>/2023/04/04/3-6%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>匿名函数是指没有定义名字符号的函数</p>
<p>除了没有名字外，匿名函数和普通函数完全相同。最大的区别是，我们可在函数内部定义匿名函数，形成嵌套效果。</p>
<p>匿名函数可直接调用，保存到变量，作为参数或返回值。</p>
<p>直接执行:</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;s&quot;</span>)</span><br><span class="line">   &#125;(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>赋值给变量：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x + y</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>作为参数：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">   f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>作为返回值</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x + y</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	add := t()</span><br><span class="line">	<span class="built_in">println</span>(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>普通函数和匿名函数都可作为结构体字段，或经通道传递</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ts</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">type</span> calc <span class="keyword">struct</span> &#123;</span><br><span class="line">      mul <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span>		<span class="comment">//函数类型字段</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   x := calc&#123;</span><br><span class="line">      mul: <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> x + y</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>(x.mul(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   c &lt;- <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x + y</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">println</span>((&lt;-c)(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ts()</span><br><span class="line">   testChannel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>匿名函数不被使用会报错</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>3-6延迟调用</title>
    <url>/2023/04/06/3-7%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p> defer语句向当前函数注册稍后执行的函数调用，被称为延迟调用。</p>
<p>直到函数执行结束前才被执行。</p>
<p>常用于资源释放、解除锁定，以为错误处理等操作。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>4-2数组</title>
    <url>/2023/04/06/4-2%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a [<span class="number">4</span>]<span class="type">int</span> <span class="comment">//元素自动初始化为0</span></span><br><span class="line">   b := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">5</span>&#125;</span><br><span class="line">   c := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">3</span>: <span class="number">10</span>&#125;     <span class="comment">//指定索引位置初始化</span></span><br><span class="line">   d := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;    <span class="comment">//编译器按照初始化值数量确定数组长度</span></span><br><span class="line">   e := [...]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">3</span>: <span class="number">100</span>&#125; <span class="comment">//支持索引初始化，但注意数组长度与此有关</span></span><br><span class="line"></span><br><span class="line">   fmt.Println(a, b, c, d, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">2</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">5</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">10</span> <span class="number">0</span> <span class="number">0</span> <span class="number">100</span>]</span><br></pre></td></tr></table></figure></div>

<p>初始化复合类型时，可省略元素初始化类型标签。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">      name <span class="type">string</span></span><br><span class="line">      age  <span class="type">byte</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   d := [...]user&#123;</span><br><span class="line">      &#123;<span class="string">&quot;tom&quot;</span>, <span class="number">20</span>&#125;,		<span class="comment">//省略了类型标签</span></span><br><span class="line">      &#123;<span class="string">&quot;mary&quot;</span>, <span class="number">18</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：在定义多维数组时，仅第一维度允许使用”…”。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span>&#123;</span><br><span class="line">      &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">      &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   b := [...][<span class="number">2</span>]<span class="type">int</span>&#123;</span><br><span class="line">      &#123;<span class="number">10</span>, <span class="number">20</span>&#125;,</span><br><span class="line">      &#123;<span class="number">30</span>, <span class="number">40</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   c := [...][<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span>&#123;</span><br><span class="line">      &#123;</span><br><span class="line">         &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">         &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &#123;<span class="number">10</span>, <span class="number">20</span>&#125;,</span><br><span class="line">         &#123;<span class="number">30</span>, <span class="number">40</span>&#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(a)</span><br><span class="line">   fmt.Println(b)</span><br><span class="line">   fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span>] [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line">[[<span class="number">10</span> <span class="number">20</span>] [<span class="number">30</span> <span class="number">40</span>]]</span><br><span class="line">[[[<span class="number">1</span> <span class="number">2</span>] [<span class="number">3</span> <span class="number">4</span>]] [[<span class="number">10</span> <span class="number">20</span>] [<span class="number">30</span> <span class="number">40</span>]]]</span><br></pre></td></tr></table></figure></div>

<p>内置函数len和cap都返回第一维度长度</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">   b := [...][<span class="number">2</span>]<span class="type">int</span>&#123;</span><br><span class="line">      &#123;<span class="number">10</span>, <span class="number">20</span>&#125;,</span><br><span class="line">      &#123;<span class="number">30</span>, <span class="number">40</span>&#125;,</span><br><span class="line">      &#123;<span class="number">50</span>, <span class="number">60</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>(<span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line">   <span class="built_in">println</span>(<span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">   <span class="built_in">println</span>(<span class="built_in">len</span>(b[<span class="number">1</span>]), <span class="built_in">cap</span>(b[<span class="number">1</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>首先区别<strong>指针数组</strong>和<strong>数组指针</strong></p>
<p>指针数组是指元素为指针类型的数组</p>
<p>数组指针是获取数组变量的地址</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   x, y := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">   a := [...]*<span class="type">int</span>&#123;&amp;x, &amp;y&#125;		<span class="comment">//元素为指针的指针数组</span></span><br><span class="line">   p := &amp;a						<span class="comment">//存储数组地址的指针</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;%T,%v\n&quot;</span>, a, a)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%T,%v\n&quot;</span>, p, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>]*<span class="type">int</span>,[<span class="number">0xc0000a6058</span> <span class="number">0xc0000a6070</span>]</span><br><span class="line">*[<span class="number">2</span>]*<span class="type">int</span>,&amp;[<span class="number">0xc0000a6058</span> <span class="number">0xc0000a6070</span>]</span><br></pre></td></tr></table></figure></div>

<p>和其他语言一样，可获取任意元素地址，</p>
<p>数组指针可以直接操作元素。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>赋值和传参操作都会复制整个数组数据。所以可以用切片和指针代替。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x [2]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;x: %p, %v\n&quot;</span>, &amp;x, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> b [<span class="number">2</span>]<span class="type">int</span></span><br><span class="line">   b = a</span><br><span class="line">   fmt.Printf(<span class="string">&quot;a: %p, %v\n&quot;</span>, &amp;a, a)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;b: %p, %v\n&quot;</span>, &amp;b, b)</span><br><span class="line"></span><br><span class="line">   test(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">a: <span class="number">0xc0000160e0</span>, [<span class="number">10</span> <span class="number">20</span>]</span><br><span class="line">b: <span class="number">0xc0000160f0</span>, [<span class="number">10</span> <span class="number">20</span>]</span><br><span class="line">x: <span class="number">0xc000016140</span>, [<span class="number">10</span> <span class="number">20</span>]</span><br></pre></td></tr></table></figure></div>

<p>使用指针和切片避免数据复制</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x *[2]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;x: %p, %v\n&quot;</span>, x, *x)</span><br><span class="line">   x[<span class="number">1</span>] += <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">   test(&amp;a)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;a: %p, %v\n&quot;</span>, &amp;a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">x: <span class="number">0xc0000a0070</span>, [<span class="number">10</span> <span class="number">20</span>]</span><br><span class="line">a: <span class="number">0xc0000a0070</span>, [<span class="number">10</span> <span class="number">120</span>]</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>4-1字符串</title>
    <url>/2023/04/06/4-1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0,</p>
<p>默认以UTF-8编码储存Unicode字符。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))     	<span class="comment">// &quot;12&quot;</span></span><br><span class="line">fmt.Println(s[<span class="number">0</span>], s[<span class="number">7</span>]) 	<span class="comment">// &quot;104 119&quot; (&#x27;h&#x27; and &#x27;w&#x27;)</span></span><br></pre></td></tr></table></figure></div>

<p>字符串的默认值不是nil，而是””</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">   <span class="built_in">println</span>(s == <span class="string">&quot;&quot;</span>)</span><br><span class="line">   <span class="built_in">println</span>(s == <span class="literal">nil</span>)	<span class="comment">//无效操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用”&#96;”定义不需要转义处理的原始字符串，支持跨行</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := <span class="string">`line\r\n,</span></span><br><span class="line"><span class="string">   line 2`</span></span><br><span class="line">   <span class="built_in">println</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">line\r\n,</span><br><span class="line">        line <span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<p>支持”!&#x3D;、&#x3D;&#x3D;、&lt;、&gt;、+、+&#x3D;”操作符</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := <span class="string">&quot;ab&quot;</span> +</span><br><span class="line">      <span class="string">&quot;cd&quot;</span></span><br><span class="line">   <span class="built_in">println</span>(s == <span class="string">&quot;abcd&quot;</span>)</span><br><span class="line">   <span class="built_in">println</span>(s != <span class="string">&quot;cd&quot;</span>)</span><br><span class="line">   <span class="built_in">println</span>(<span class="built_in">len</span>(s) &gt; <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>允许以索引号访问字节数组，但不能获取元素地址。</strong></p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">   <span class="built_in">println</span>(s[<span class="number">1</span>])</span><br><span class="line">   <span class="built_in">println</span>(&amp;s[<span class="number">2</span>])	<span class="comment">//invalid operation: cannot take address of s[2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>切片返回子串，依旧指向原数组</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   s := <span class="string">&quot;abcdef&quot;</span></span><br><span class="line">   s1 := s[:<span class="number">3</span>]  	<span class="comment">//从头开始，仅指定结束索引位置</span></span><br><span class="line">   s2 := s[<span class="number">1</span>:<span class="number">4</span>] 	<span class="comment">//指定开始和结束位置，返回[start,end]</span></span><br><span class="line">   s3 := s[<span class="number">2</span>:]  	<span class="comment">//指定开始位置，返回后面全部内容</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">println</span>(s1, s2, s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用for，分byte和rune两种方式</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   s := <span class="string">&quot;memo&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//byte</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;%d: %X\n&quot;</span>, i, s[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//rune</span></span><br><span class="line">   <span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;%d: %U\n&quot;</span>, i, c)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="number">6</span>D</span><br><span class="line"><span class="number">1</span>: <span class="number">65</span></span><br><span class="line"><span class="number">2</span>: <span class="number">6</span>D</span><br><span class="line"><span class="number">3</span>: <span class="number">6</span>F</span><br><span class="line"><span class="number">0</span>: U+<span class="number">006</span>D</span><br><span class="line"><span class="number">1</span>: U+<span class="number">0065</span></span><br><span class="line"><span class="number">2</span>: U+<span class="number">006</span>D</span><br><span class="line"><span class="number">3</span>: U+<span class="number">006</span>F</span><br></pre></td></tr></table></figure></div>

<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>如果要修改字符串，需要将其转换为可变类型rune和byte，完成后再转换回来。</p>
<p>但是转换必须重新分配内存，并复制数据。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   s := strings.Repeat(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 分配内存、复制</span></span><br><span class="line">   bs := []<span class="type">byte</span>(s)</span><br><span class="line">   bs[<span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//分配内存、复制</span></span><br><span class="line">   s2 := <span class="type">string</span>(bs)</span><br><span class="line"></span><br><span class="line">   hs := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">   hbs := (*reflect.SliceHeader)(unsafe.Pointer(&amp;bs))</span><br><span class="line">   hs2 := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s2))</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%#v\n%#v\n%#v\n&quot;</span>, hs, hbs, hs2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>4-3切片</title>
    <url>/2023/04/06/4-3%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>切片本身并非动态数组或数组指针。它内部通过指针引用底层数组，设置相关属性将数据读写操作限定在指定区域内。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">x := [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>expression</th>
<th>slice</th>
<th>len</th>
<th>cap</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>x[:]</td>
<td>[0 1 2 3 4 5 6 7 8 9]</td>
<td>10</td>
<td>10</td>
<td></td>
</tr>
<tr>
<td>x[2:5]</td>
<td>[2 3 4]</td>
<td>3</td>
<td>8</td>
<td>x[0:len(x)]</td>
</tr>
<tr>
<td>x[2:5:7]</td>
<td>[2 3 4]</td>
<td>3</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>x[4:]</td>
<td>[4 5 6 7 8 9]</td>
<td>6</td>
<td>6</td>
<td>x[4:len(x)]</td>
</tr>
<tr>
<td>x[:4]</td>
<td>[0 1 2 3]</td>
<td>4</td>
<td>10</td>
<td>x[0:4]</td>
</tr>
<tr>
<td>x[:4:6]</td>
<td>[0 1 2 3]</td>
<td>4</td>
<td>6</td>
<td>x[0:4:6]</td>
</tr>
</tbody></table>
<p>len返回元素数量，cap返回容量。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>可以直接创建切片对象，无须预先准备数组。</p>
<p>因为是引用类型，须使用make函数或显式初始化语句，</p>
<p>它会自动完成底层数组内存分配。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)		<span class="comment">//指定 len、cap,底层数组初始化为0</span></span><br><span class="line">    s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)		<span class="comment">//省略 cap和len相等</span></span><br><span class="line">    s3 := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>: <span class="number">30</span>&#125;	<span class="comment">//按初始化元素分配底层数组，并设置len、cap</span></span><br><span class="line">    fmt.Println(s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line">    fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">    fmt.Println(s3, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]				<span class="number">3</span> <span class="number">5</span></span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]				<span class="number">3</span> <span class="number">3</span></span><br><span class="line">[<span class="number">10</span> <span class="number">20</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">30</span>]	<span class="number">6</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></div>

<p>切片本身只是个只读对象，其工作机制类似数组指针的包装</p>
<p>仅能判断是否为nil，不支持其他比较操作</p>
<p>可以获取元素地址，但不能直接用指针访问元素内容</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    </span><br><span class="line">    p := &amp;s		<span class="comment">//取 header地址</span></span><br><span class="line">    p0 := &amp;s[<span class="number">0</span>]	<span class="comment">//取 array[0] 地址</span></span><br><span class="line">    p1 := &amp;s[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println</span>(p, p0, p1)</span><br><span class="line">    </span><br><span class="line">    (*p)[<span class="number">0</span>] += <span class="number">100</span>	<span class="comment">//*[]int不支持索引操作，须先返回 []int 对象</span></span><br><span class="line">    *p1 += <span class="number">100</span>		<span class="comment">//直接用元素指针操作</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0xc0000a9f58</span> <span class="number">0xc00000e3f0</span> <span class="number">0xc00000e3f8</span></span><br><span class="line">[<span class="number">100</span> <span class="number">101</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure></div>

<h2 id="reslice切片重组"><a href="#reslice切片重组" class="headerlink" title="reslice切片重组"></a>reslice切片重组</h2><p>改变切片长度的过程称之为切片重组 <strong>reslicing</strong>，</p>
<p>这么做的好处是我们的切片在达到容量上限后可以扩容。</p>
<p><strong>示例：切片拓展一位</strong></p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">sl = sl[<span class="number">0</span>:<span class="built_in">len</span>(sl)+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></div>

<p>依照原切片对象创建的新切片，</p>
<p>所指向的位置依旧是原底层数组，如果修改，</p>
<p>将对所有关联的切片可见变化。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   d := [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">   s1 := d[<span class="number">3</span>:<span class="number">7</span>]</span><br><span class="line">   s2 := s1[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">      s2[i] += <span class="number">100</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(d)</span><br><span class="line">   fmt.Println(s1)</span><br><span class="line">   fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">104</span> <span class="number">105</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">[<span class="number">3</span> <span class="number">104</span> <span class="number">105</span> <span class="number">6</span>]</span><br><span class="line">[<span class="number">104</span> <span class="number">105</span>]</span><br></pre></td></tr></table></figure></div>

<h2 id="append追加"><a href="#append追加" class="headerlink" title="append追加"></a>append追加</h2><p>向切片尾部添加数据，返回新的切片对象。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">   s1 := <span class="built_in">append</span>(s, <span class="number">10</span>)</span><br><span class="line">   s2 := <span class="built_in">append</span>(s1, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">   </span><br><span class="line">   fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">   fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">   fmt.Println(s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">[] 			<span class="number">0</span> <span class="number">5</span></span><br><span class="line">[<span class="number">10</span>] 		<span class="number">1</span> <span class="number">5</span></span><br><span class="line">[<span class="number">10</span> <span class="number">10</span> <span class="number">20</span>] 	<span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></div>

<p>数据被追加到原底层数组。如果超出cap限制，则为新切片对象重新分配数组。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">   s1 := s[:<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">   s2 := <span class="built_in">append</span>(s1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">//超出cap限制，重新分配新底层数组</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;s1: %p: %v\n&quot;</span>, &amp;s1[<span class="number">0</span>], &amp;s1)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;s2: %p: %v\n&quot;</span>, &amp;s2[<span class="number">0</span>], &amp;s2)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;s data: %v\n&quot;</span>, s[:<span class="number">10</span>])</span><br><span class="line">   fmt.Printf(<span class="string">&quot;s1 cap: %d, s2 cap: %d\n&quot;</span>, <span class="built_in">cap</span>(s1), <span class="built_in">cap</span>(s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">s1: <span class="number">0xc000020380</span>: &amp;[<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">s2: <span class="number">0xc00001c300</span>: &amp;[<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]	<span class="comment">//数组地址不同，确定是重新分配</span></span><br><span class="line">s data: [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]			<span class="comment">//apppend并未向原数组写入数据</span></span><br><span class="line">s1 <span class="built_in">cap</span>: <span class="number">4</span>, s2 <span class="built_in">cap</span>: <span class="number">8</span>					<span class="comment">//新数组是原cap的2倍</span></span><br></pre></td></tr></table></figure></div>

<p>需要注意的是：</p>
<ul>
<li>超出cap切片的限制，而不是底层数组长度len限制</li>
<li>新分配数组cap长度是原cap的2倍，而不是原数组cap的2倍</li>
</ul>
<h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>在两个切片前复制数据：</p>
<ul>
<li>允许指向同一数组。</li>
<li>允许目标区间重叠</li>
<li>复制长度以较短len切片为准</li>
</ul>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">   s1 := s[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">   n := <span class="built_in">copy</span>(s[<span class="number">4</span>:], s1) 	<span class="comment">//同一底层数组的不同区间复制</span></span><br><span class="line">   fmt.Println(n, s)</span><br><span class="line">   s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">6</span>) 	<span class="comment">//在不同数组间复制</span></span><br><span class="line">   n = <span class="built_in">copy</span>(s2, s)</span><br><span class="line">   fmt.Println(n, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> 	[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"><span class="number">6</span> 	[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>4-4字典</title>
    <url>/2023/04/07/4-4%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>字典本质就是一种通过哈希表存储查找键值对，是一种特殊的数据结构</p>
<p>字典也是引用类型，使用make函数或初始化表达式语句来创建。</p>
<div class="highlight-container" data-rel="Tex"><figure class="iseeu highlight tex"><table><tr><td class="code"><pre><span class="line">/* 声明变量，默认 map 是 nil */</span><br><span class="line">var mapName map[mapKey]mapValue</span><br><span class="line"></span><br><span class="line">/* 使用 make 函数 */</span><br><span class="line">mapName := make(map[mapKey]mapValue)</span><br></pre></td></tr></table></figure></div>

<p>演示：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    m[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">    m[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="type">int</span>] <span class="keyword">struct</span> &#123;	<span class="comment">//值为匿名结构类型</span></span><br><span class="line">        x <span class="type">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        <span class="number">1</span>: &#123;x: <span class="number">100</span>&#125;,	<span class="comment">//可省略key value类型标签</span></span><br><span class="line">        <span class="number">2</span>: &#123;x: <span class="number">200</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(m, m2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[a:<span class="number">1</span> b:<span class="number">2</span>] </span><br><span class="line"><span class="keyword">map</span>[<span class="number">1</span>:&#123;<span class="number">100</span>&#125; <span class="number">2</span>:&#123;<span class="number">200</span>&#125;]</span><br></pre></td></tr></table></figure></div>

<p>访问不存在的键值，默认返回0值，不会报错。</p>
<p>通过0值无法判断键值是否存在，因为可能存入的值就是0</p>
<p>基本操作演示：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">      <span class="string">&quot;a&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;b&quot;</span>: <span class="number">2</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m[<span class="string">&quot;a&quot;</span>] = <span class="number">10</span> 		<span class="comment">//修改</span></span><br><span class="line">   m[<span class="string">&quot;c&quot;</span>] = <span class="number">30</span> 		<span class="comment">//新增</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> v, ok := m[<span class="string">&quot;a&quot;</span>]; ok &#123; 	<span class="comment">//使用ok-idiom判断key是否存在，返回值</span></span><br><span class="line">      <span class="built_in">println</span>(v)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> v, ok := m[<span class="string">&quot;d&quot;</span>]; ok &#123; 	<span class="comment">//使用ok-idiom判断key是否存在，返回值</span></span><br><span class="line">      <span class="built_in">println</span>(v)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">delete</span>(m, <span class="string">&quot;d&quot;</span>) 		<span class="comment">//删除键值对。不存在时也不会报错</span></span><br><span class="line">   fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="keyword">map</span>[a:<span class="number">10</span> b:<span class="number">2</span> c:<span class="number">30</span>]</span><br></pre></td></tr></table></figure></div>

<p>函数len返回当前键值对数量，cap不接受字典类型。</p>
<p>由于访问安全，字典被设计为“not addressable”</p>
<p>所以不能直接修改value成员。</p>
<p>正确做法是返回整个value，再修改。</p>
<p>错误演示：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">      name <span class="type">string</span></span><br><span class="line">      age  <span class="type">byte</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m := <span class="keyword">map</span>[<span class="type">int</span>]user&#123;</span><br><span class="line">      <span class="number">1</span>: &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m[<span class="number">1</span>].age += <span class="number">1</span> 	<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>正确修改：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">      name <span class="type">string</span></span><br><span class="line">      age  <span class="type">byte</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m := <span class="keyword">map</span>[<span class="type">int</span>]user&#123;</span><br><span class="line">      <span class="number">1</span>: &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">19</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   u := m[<span class="number">1</span>]</span><br><span class="line">   u.age += <span class="number">1</span></span><br><span class="line">   m[<span class="number">1</span>] = u			<span class="comment">//设置整个value</span></span><br><span class="line"></span><br><span class="line">   m2 := <span class="keyword">map</span>[<span class="type">int</span>]*user&#123;		<span class="comment">//value是指针类型</span></span><br><span class="line">      <span class="number">1</span>: &amp;user&#123;<span class="string">&quot;jack&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   m2[<span class="number">1</span>].age++		<span class="comment">//m2[1] 返回的是指针，可透过指针修改目标对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>4-5结构</title>
    <url>/2023/04/07/4-5%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>结构体将多个不同类型命名字段序列打包成一个复合类型。</p>
<p>字段名必须唯一，可用”_”补位，支持使用自身指针类型成员。</p>
<p>例一：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">   _    <span class="type">int</span></span><br><span class="line">   id   <span class="type">int</span></span><br><span class="line">   next *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   n1 := node&#123;</span><br><span class="line">      id: <span class="number">1</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   n2 := node&#123;</span><br><span class="line">      id:   <span class="number">2</span>,</span><br><span class="line">      next: &amp;n1,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(n1, n2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">0</span> <span class="number">1</span> &lt;<span class="literal">nil</span>&gt;&#125; &#123;<span class="number">0</span> <span class="number">2</span> <span class="number">0xc00010e060</span>&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h2><p>可以直接定义匿名结构类型变量。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := <span class="keyword">struct</span> &#123; <span class="comment">//直接定义匿名结构变量</span></span><br><span class="line">       name <span class="type">string</span></span><br><span class="line">       age  <span class="type">byte</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">       name: <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">       age:  <span class="number">12</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>只有所有字段类型全部支持时，才能比较是否相等</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">      x <span class="type">int</span></span><br><span class="line">      y <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   d1 :=data&#123;</span><br><span class="line">      x: <span class="number">100</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   d2 :=data&#123;</span><br><span class="line">      x: <span class="number">100</span>,</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">println</span>(d1 == d2)	<span class="comment">//无效操作: map没有被比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="空结构"><a href="#空结构" class="headerlink" title="空结构"></a>空结构</h2><p>空结构是指没有字段的结构类型。</p>
<p>它的特殊在于，无论是自身，还是作为数组元素类型，其长度都为0。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">100</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println</span>(unsafe.Sizeof(a), unsafe.Sizeof(b))	<span class="comment">// 0 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实际上，这些长度为0的对象通常指向runtime.zerobase变量</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">10</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    b := a[:]		<span class="comment">//底层数组指向 zerobase，而非 slice</span></span><br><span class="line">    c := [<span class="number">0</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %p, %p\n&quot;</span>, &amp;a[<span class="number">0</span>], &amp;b[<span class="number">0</span>], &amp;c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出:</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0x19c730</span>, <span class="number">0x19c730</span>, <span class="number">0x19c730</span></span><br></pre></td></tr></table></figure></div>

<p>zerobase是一个 <code>uintptr</code> 全局变量，占用 8 个字节。当在任何地方定义无数个 <code>struct &#123;&#125;</code> 类型的变量，编译器都只是把这个 <code>zerobase</code> 变量的地址给出去。换句话说，在 golang 里面，涉及到所有内存 size 为 0 的内存分配，那么就是用的同一个地址.</p>
<h2 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h2><p>匿名字段是指没有名字，仅有类型的字段，也被称作嵌入字段或嵌入类型。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> attr <span class="keyword">struct</span> &#123;</span><br><span class="line">    perm <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    attr		<span class="comment">// 仅有类型名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>编译器认为，匿名字段是隐式的以类型名为字段名称。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	attr <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	perm <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> attr <span class="keyword">struct</span> &#123;</span><br><span class="line">	perm <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := file&#123;</span><br><span class="line">		name: <span class="string">&quot;test.dat&quot;</span>,</span><br><span class="line">		attr: attr&#123;		<span class="comment">//显式初始化匿名字段</span></span><br><span class="line">			perm: <span class="number">0755</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	f.perm = <span class="number">0644</span>		<span class="comment">//直接设置匿名字段成员</span></span><br><span class="line">	<span class="built_in">println</span>(f.perm)		<span class="comment">//直接读取匿名字段成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果嵌入其他包中的类型，则隐式字段名字不包括包名</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d := data &#123;</span><br><span class="line">		File: os.File(),</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>,d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>除了接口指针和多级指针以外，任何命名类型都可以作为匿名字段。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	*<span class="type">int</span></span><br><span class="line">    <span class="type">int</span> 	<span class="comment">//不能基础类型和其指针类型一起嵌入，二者隐式名字相同.</span></span><br><span class="line">    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">100</span></span><br><span class="line">    d := data&#123;</span><br><span class="line">        <span class="type">int</span>: &amp;x,</span><br><span class="line">        <span class="type">string</span> <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>,d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>匿名字段可能存在重名问题。</p>
<p>如果匿名字段被外层同名字段遮蔽，则必须使用显式字段名。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    file</span><br><span class="line">    name <span class="type">string</span>		<span class="comment">//与匿名字段 file.name 重名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := data &#123;</span><br><span class="line">        name: <span class="string">&quot;data&quot;</span>,</span><br><span class="line">        file: file&#123;<span class="string">&quot;file&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    d.name = <span class="string">&quot;data2&quot;</span>		<span class="comment">//访问data.name</span></span><br><span class="line">    d.file.name = <span class="string">&quot;file2&quot;</span>	<span class="comment">//使用显式字段名访问 data.file.name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h2><p>字段标签不是注释，而是对字段进行描述的元数据。</p>
<p>不属于数据成员，但是是类型的组成部分。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span> <span class="string">&#x27;昵称&#x27;</span></span><br><span class="line">	sex <span class="type">byte</span> <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := user&#123;<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">	v := reflect.ValueOf(u)		<span class="comment">//反射获取标签信息</span></span><br><span class="line">	t := v.Type()</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i, n := <span class="number">0</span>, t.NumField(); i &lt; n; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s: %v\n&quot;</span>, t.Filed(i).Tag, v.Field(i))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">昵称：tom</span><br><span class="line">性别：1</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>5-1方法定义</title>
    <url>/2023/04/08/5-1%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Golang中的方法是作用在指定的数据类型上的（即，与指定数据类型绑定），因此自定义类型都可以有方法，不仅仅是struct。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    Num <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span>test() &#123;</span><br><span class="line">    fmt.Println(a.Num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) func (a A)test() &#123;&#125; 表示 A结构体有一个方法，方法名为 test</span></span><br><span class="line"><span class="comment">// 2) (a A)体现 test方法是和 A类型绑定的</span></span><br></pre></td></tr></table></figure></div>

<p>方法不支持重载，但对参数名无限制，如果方法内部并不引用实例，可省略参数名，仅保留类型。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(N)</span></span> test() &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hi!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>方法可视为特殊的函数，那么接受的参数的类型同样可以影响调用对象实例时是否被复制。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> N <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n N)</span></span> test() &#123;</span><br><span class="line">   n++</span><br><span class="line">   fmt.Printf(<span class="string">&quot;v: %p, %v\n&quot;</span>, &amp;n, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *N)</span></span> pointer() &#123;</span><br><span class="line">   *(n)++</span><br><span class="line">   fmt.Printf(<span class="string">&quot;p: %p, %v\n&quot;</span>, n, *n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">   a.test()</span><br><span class="line">   a.pointer()</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;a: %p, %v\n&quot;</span>, &amp;a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">v: <span class="number">0xc0000160e0</span>, <span class="number">26</span></span><br><span class="line">p: <span class="number">0xc0000160c8</span>, <span class="number">26</span></span><br><span class="line">a: <span class="number">0xc0000160c8</span>, <span class="number">26</span></span><br></pre></td></tr></table></figure></div>

<p>不能使用多级指针调用方法，但接受参数可以在基础和指针类型间转换。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a N = <span class="number">25</span></span><br><span class="line">	p := &amp;a</span><br><span class="line">   a.test()</span><br><span class="line">   a.pointer()</span><br><span class="line">   </span><br><span class="line">   p.test()</span><br><span class="line">   p.pointer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="选择方法的接受类型"><a href="#选择方法的接受类型" class="headerlink" title="选择方法的接受类型"></a>选择方法的接受类型</h2><ul>
<li>要修改实例状态，用*T</li>
<li>无须修改状态的小对象或固定值，建议用T</li>
<li>大对象建议用*T，减少复制成本</li>
<li>引用类型、字符串、函数等指针包装对象，直接用T</li>
<li>若包含Mutex等同步字段，用*T，避免因复制造成锁操作无效</li>
<li>其他无法确定情况，都有*T</li>
</ul>
<h2 id="方法与函数区别"><a href="#方法与函数区别" class="headerlink" title="方法与函数区别"></a>方法与函数区别</h2><ol>
<li><p>调用方法不同：</p>
<p>函数调用：<strong>函数名（实参列表）</strong></p>
<p>方法调用：<strong>变量.方法名（实参列表）</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>5-2匿名字段</title>
    <url>/2023/04/10/5-2%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5/</url>
    <content><![CDATA[<p> 之前在结构体介绍了匿名字段，方法里也可以像访问匿名字段那样调用方法。</p>
<p>由于方法也有同名遮蔽问题。但利用这种特性，可实现类似覆盖重写操作（override）</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> manager <span class="keyword">struct</span> &#123;</span><br><span class="line">   user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user)</span></span> toString() <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m manager)</span></span> toString() <span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> m.user.toString() + <span class="string">&quot;; manager&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> m manager</span><br><span class="line">   <span class="built_in">println</span>(m.toString())</span><br><span class="line">   <span class="built_in">println</span>(m.user.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line">user; manager</span><br><span class="line">user</span><br></pre></td></tr></table></figure></div>

<p>和匿名字段访问类似，按照最小深度优先原则</p>
<p>如两个同名方法深度相同，那么编译器无法作出选择，需显式指定。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>5-3方法集</title>
    <url>/2023/04/10/5-3%E6%96%B9%E6%B3%95%E9%9B%86/</url>
    <content><![CDATA[<p> 每个类型都有与之相关的类型，把这个类型所以方法称为类型的方法集</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">        age <span class="type">int8</span></span><br><span class="line">        name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span></span> showName() &#123;</span><br><span class="line">        fmt.Println(s.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> setName(newName <span class="type">string</span>) &#123;</span><br><span class="line">        s.name = newName</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型Student方法集包含了showName()方法。</span></span><br><span class="line"><span class="comment">// 类型*Student方法集包含了showName()方法和setName()方法。</span></span><br></pre></td></tr></table></figure></div>

<p>● 类型T方法集，包含全部receiver T 方法。</p>
<p>● 类型*T方法集，包含全部receiver T + *T方法。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>7-1并发</title>
    <url>/2023/04/11/7-1%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>聊并发就一定离不开并行与并发的讨论</p>
<h2 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h2><ul>
<li>并发：逻辑上具备同时处理多个任务的能力。</li>
<li>并行：物理上在同一时刻执行多个并发任务。</li>
</ul>
<p>虽然说程序是并发设计，但并不一定代表多个任务在同一时刻发生。</p>
<p>单核处理器通常以间隔方式切换执行。</p>
<p>并行更依赖多核处理器的物理设备，让多个任务真正同时执行，</p>
<p><strong>并发是并行的必要条件，并行是并发设计的理想执行模式</strong></p>
<h2 id="创建并发任务"><a href="#创建并发任务" class="headerlink" title="创建并发任务"></a>创建并发任务</h2><p>在目标函数和参数调用前添加go关键字即可创建并发任务。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打包并发任务</span></span><br><span class="line">	<span class="comment">// 并非立即执行</span></span><br><span class="line">	<span class="keyword">go</span> <span class="built_in">println</span>(<span class="string">&quot;hello,world!&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(s)</span><br><span class="line">	&#125;(<span class="string">&quot;hello, world!&quot;</span>)</span><br><span class="line">	<span class="comment">// 上述并发任务会被其他饥饿线程取走</span></span><br><span class="line">	<span class="comment">// 执行时间未知，所以下面的输出可能先执行</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;abcd&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abcd</span></span><br><span class="line"><span class="comment">// hello, world!</span></span><br><span class="line"><span class="comment">// hello,world!</span></span><br></pre></td></tr></table></figure></div>

<p>关键字go并非执行并发操作，而是创建一个并发任务单元，放入待运行队列。</p>
<p>无法确定执行时间、次序、执行线程。</p>
<p>统一由调度器负责处理。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 延迟执行，立即计算并复制执行参数</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inc</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   c++</span><br><span class="line">   <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := <span class="number">100</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">       		<span class="comment">// sleep 是让下面的main输出先输出</span></span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;go:&quot;</span>, x, y)	<span class="comment">//100, 1</span></span><br><span class="line">   &#125;(a, inc())	<span class="comment">//计算并复制参数</span></span><br><span class="line">   </span><br><span class="line">   a += <span class="number">100</span></span><br><span class="line">   <span class="built_in">println</span>(<span class="string">&quot;main:&quot;</span>, a, inc())	<span class="comment">//200, 2</span></span><br><span class="line"></span><br><span class="line">   time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main: 200 2</span></span><br><span class="line"><span class="comment">//go: 100 1</span></span><br></pre></td></tr></table></figure></div>

<h2 id="Wait等待"><a href="#Wait等待" class="headerlink" title="Wait等待"></a>Wait等待</h2><p>进程的结束，不会等待其他正在执行或尚未执行的任务。</p>
<p>用wait可以比time.Sleep更好一点。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>测试</category>
        <category>测试1</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>简述Go语言和博客目的</title>
    <url>/2023/03/30/%E7%AE%80%E8%BF%B0Go%E8%AF%AD%E8%A8%80%E5%92%8C%E5%8D%9A%E5%AE%A2%E7%9B%AE%E7%9A%84/</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>作为一个小白，对于go语言的理解是浅薄的，对go语言的优势劣势也并无能能力为大家解释清楚。</p>
<p>所以由于本身是第一次接触go语言，我也只能尽自己的力量从0开始由基础向上迈步。</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>个人还是以丰富自身巩固学习为前提，本Go博客栏的编写依照个人的学习和阅读。</p>
<p> p :&#x3D; (*int)(&amp;x2)println(“p: “, *p)go</p>
<p>所以举例的代码大多也从书中运行实践后摘抄分享</p>
<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><p>[Go语言中文网](<a class="link"   href="https://studygolang.com/" >首页 - Go语言中文网 - Golang中文社区 (studygolang.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</p>
<p>[Golang语言标准库文档](<a class="link"   href="https://studygolang.com/pkgdoc" >Go语言标准库文档中文版 | Go语言中文网 | Golang中文社区 | Golang中国 (studygolang.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</p>
<p>雨痕大大Go程序设计<a class="link"   href="https://www.yuque.com/qyuhen/go" >Go 程序设计 (yuque.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>6-1接口</title>
    <url>/2023/04/10/6-1%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>接口代表一种调用契约，是多个方法声明的集合。</p>
<p>只要目标类型方法集包含接口声明的全部方法，就视为实现该接口，<strong>无需显式声明</strong>，目标类型可实现多个接口。</p>
<ul>
<li>不能有字段</li>
<li>不能定义自己的方法</li>
<li>只能声明方法，不能实现</li>
<li>可嵌入其他接口类型</li>
</ul>
<p>接口通常以er作为名词后缀，方法名是声明组成部分，但参数名可不同或省略。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> tester <span class="keyword">interface</span> &#123;</span><br><span class="line">   test()</span><br><span class="line">   <span class="type">string</span>() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*data)</span></span> test() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data)</span></span> <span class="type">string</span>() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> d data</span><br><span class="line">   <span class="keyword">var</span> t tester = &amp;d</span><br><span class="line">   t.test()</span><br><span class="line">   <span class="built_in">println</span>(t.<span class="type">string</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果接口没有任何方法声明，那么就是一个空接口，</p>
<p>它的用途类似面向对象里的根类型Object，可被赋值为任何类型的对象。</p>
<p>接口变量默认值是nil，如果实现接口的类型支持，</p>
<p>空接口可被赋值任何对象，可做相等运算。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">   <span class="keyword">var</span> t1, t2 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="built_in">println</span>(t1 == <span class="literal">nil</span>, t1 == t2)</span><br><span class="line"></span><br><span class="line">   t1, t2 = <span class="number">100</span>, <span class="number">100</span></span><br><span class="line">   <span class="built_in">println</span>(t1 == <span class="literal">nil</span>, t1 == t2)</span><br><span class="line">   t1, t2 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">   <span class="built_in">println</span>(t1 == t2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> <span class="literal">true</span></span><br><span class="line"><span class="literal">false</span> <span class="literal">true</span></span><br><span class="line"><span class="built_in">panic</span>: runtime <span class="type">error</span>: comparing uncomparable <span class="keyword">type</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure></div>

<h2 id="匿名嵌入"><a href="#匿名嵌入" class="headerlink" title="匿名嵌入"></a>匿名嵌入</h2><p>像匿名字段那样，嵌入其他接口。目标类型方法集中，必须包含嵌入接口在内的全部方法实现。</p>
<ul>
<li>相当于导入声明，非继承</li>
<li>不能嵌入自身或循环嵌入</li>
<li>不允许声明重载</li>
<li>允许签名相同的声明（并集去重）</li>
<li>鼓励小接口嵌入组合</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin框架快速入门</title>
    <url>/2023/04/12/Gin%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="安装Gin"><a href="#安装Gin" class="headerlink" title="安装Gin"></a>安装Gin</h2><p>安装gin框架先安装Go并设置go工作区</p>
<ol>
<li>下载并安装 gin：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在工作区main中导入包：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>注意：如果出现import报错，可能是go本身特性，需要调用才能导入，所以要创建gin服务。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个服务</span></span><br><span class="line">ginServer := gin.Default()</span><br></pre></td></tr></table></figure>

<p>还有另一种可能是环境配置问题，在go module中更改</p>
<p><img src="C:\Users\Memorize_Mint\AppData\Roaming\Typora\typora-user-images\image-20230412182620168.png" alt="image-20230412182620168"></p>
<p>查看goroot和gopath路径是否正确。</p>
<h2 id="HELLO-GIN"><a href="#HELLO-GIN" class="headerlink" title="HELLO_GIN"></a>HELLO_GIN</h2><p>简单服务示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建一个服务</span></span><br><span class="line">   ginServer := gin.Default()</span><br><span class="line">   <span class="comment">// 访问地址，处理我们请求</span></span><br><span class="line">   ginServer.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">      context.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;hello,world&quot;</span>&#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//服务器端口</span></span><br><span class="line">   ginServer.Run(<span class="string">&quot;:8082&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问localhost:8082/hello</span></span><br><span class="line"><span class="comment">// 将会看见 msg: hello,world</span></span><br></pre></td></tr></table></figure>

<p>注意使用阶段随时查源码。</p>
<h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><h3 id="RestFul-API介绍"><a href="#RestFul-API介绍" class="headerlink" title="RestFul API介绍"></a>RestFul API介绍</h3><p>所谓restful架构主要是满足了http协议，对资源的操作包括获取、创建、修改和删除，其他的东西需要时补充。</p>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
<h3 id="go-实现"><a href="#go-实现" class="headerlink" title="go 实现"></a>go 实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">get /user		(<span class="keyword">select</span>)</span><br><span class="line">post /user		(create)</span><br><span class="line">put /user		(update)</span><br><span class="line"><span class="built_in">delete</span> /user	(<span class="built_in">delete</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ginServer.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">	context.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;hello,world&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">ginServer.POST(<span class="string">&quot;/user&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">	context.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;post user&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">ginServer.PUT(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">	context.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;put user&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">ginServer.DELETE(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">	context.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;delete user&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>处理请求：可以使用postapi可以调试接口运行是否响应</p>
<p><img src="C:\Users\Memorize_Mint\AppData\Roaming\Typora\typora-user-images\image-20230412190319635.png" alt="image-20230412190319635"></p>
<h2 id="响应页面给前端"><a href="#响应页面给前端" class="headerlink" title="响应页面给前端"></a>响应页面给前端</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/thinkerou/favicon&quot;</span></span><br><span class="line">   <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建一个服务</span></span><br><span class="line">   ginServer := gin.Default()</span><br><span class="line">   ginServer.Use(favicon.New(<span class="string">&quot;./redefine-favicon.svg&quot;</span>))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 加载静态页面</span></span><br><span class="line">   ginServer.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>) <span class="comment">//全局加载</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载资源文件(css+js)</span></span><br><span class="line">   ginServer.Static(<span class="string">&quot;/static&quot;</span>, <span class="string">&quot;./static&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//响应一个页面给前端</span></span><br><span class="line">   ginServer.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">      context.HTML(http.StatusOK, <span class="string">&quot;index.html&quot;</span>, gin.H&#123;</span><br><span class="line">         <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;这是go后端传来的数据&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//服务器端口</span></span><br><span class="line">   ginServer.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取请求参数</span></span><br><span class="line"><span class="comment">// 传统传参: url?userid=001&amp;username=memorize-mint</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/user/info&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">    userid := context.Query(<span class="string">&quot;userid&quot;</span>)</span><br><span class="line">	username := context.Query(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">	context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;userid&quot;</span>: userid, <span class="string">&quot;username&quot;</span>: username&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// restful请求: /user/info/001/memorize-mint</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/user/info/:userid/:username&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">	userid := context.Param(<span class="string">&quot;userid&quot;</span>)</span><br><span class="line">	username := context.Param(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">	context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;userid&quot;</span>: userid, <span class="string">&quot;username&quot;</span>: username&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行结果（两种）：</p>
<p><img src="C:\Users\Memorize_Mint\AppData\Roaming\Typora\typora-user-images\image-20230412194405097.png" alt="image-20230412194405097"></p>
<p><img src="C:\Users\Memorize_Mint\AppData\Roaming\Typora\typora-user-images\image-20230412194839452.png" alt="image-20230412194839452"></p>
<h3 id="传递jso序列化"><a href="#传递jso序列化" class="headerlink" title="传递jso序列化"></a>传递jso序列化</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前端给后端传 json(序列化)</span></span><br><span class="line">ginServer.POST(<span class="string">&quot;json&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">   a, _ := context.GetRawData()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="comment">// 获取数据</span></span><br><span class="line">   _ = json.Unmarshal(a, &amp;m)</span><br><span class="line">   <span class="comment">// 传递数据</span></span><br><span class="line">   context.JSON(http.StatusOK, m)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Memorize_Mint\AppData\Roaming\Typora\typora-user-images\image-20230412195542801.png" alt="image-20230412195542801"></p>
<h3 id="表单数据传输"><a href="#表单数据传输" class="headerlink" title="表单数据传输"></a>表单数据传输</h3><p>和上面的内容差不多，直接贴代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user/add&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span> 提交 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ginServer.POST(<span class="string">&quot;/user/add&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">   username := context.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">   password := context.PostForm(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">   context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;msg&quot;</span>:      <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">      <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">      <span class="string">&quot;password&quot;</span>: password,</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">   <span class="comment">//重定向301</span></span><br><span class="line">   context.Redirect(http.StatusMovedPermanently, <span class="string">&quot;http://www.meorize-mint.top&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由组 /user/add</span></span><br><span class="line">userGroup := ginServer.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	userGroup.GET(<span class="string">&quot;/add&quot;</span>)</span><br><span class="line">	userGroup.GET(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">	userGroup.GET(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">order := ginServer.Group(<span class="string">&quot;/order&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	order.GET(<span class="string">&quot;/add&quot;</span>)</span><br><span class="line">	order.DELETE(<span class="string">&quot;/delete&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>gin</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>gin</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin入门:实现用户注册demo</title>
    <url>/2023/04/16/Gin%E5%85%A5%E9%97%A8-%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8Cdemo/</url>
    <content><![CDATA[<h2 id="实现用户注册流程"><a href="#实现用户注册流程" class="headerlink" title="实现用户注册流程"></a>实现用户注册流程</h2><ol>
<li>获取参数</li>
<li>数据验证</li>
<li>创建用户</li>
<li>写入数据库</li>
<li>返回结果</li>
</ol>
<h3 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h3><p>首先这里模拟获取参数通过<strong>GET</strong>或者<strong>POST</strong>进行连接获取，</p>
<p>先创建声明相关路由，便于本地查询访问。</p>
<p>最基本就是创建一个<strong>ginServer</strong>服务和服务端口的设置。</p>
<p>在POST&#x2F;GET中通过<strong>PostForm</strong>获取参数信息。</p>
<h3 id="验证数据"><a href="#验证数据" class="headerlink" title="验证数据"></a>验证数据</h3><p>验证数据自行根据需求填写方法。</p>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>创建用户和数据库是联动的，</p>
<p>go中对于mysql连接常用于grom</p>
<p>grom官网：<a href="https://gorm.io/zh_CN/docs/index.html">GORM 指南 | GORM - The fantastic ORM library for Golang, aims to be developer friendly.</a></p>
<p>按照流程先对用户对象创建一个Model结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">   gorm.Model</span><br><span class="line">   Name      <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(20);not null&quot;`</span></span><br><span class="line">   Telephone <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(20);not unique&quot;`</span></span><br><span class="line">   Password  <span class="type">string</span> <span class="string">`gorm:&quot;size:255;not null&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们要获取数据库，</p>
<p>获取数据库需要初始化本地数据库的信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitDB</span><span class="params">()</span></span> *gorm.DB &#123;</span><br><span class="line">   host := <span class="string">&quot;localhost&quot;</span></span><br><span class="line">   port := <span class="string">&quot;3306&quot;</span></span><br><span class="line">   database := <span class="string">&quot;ginessential&quot;</span></span><br><span class="line">   username := <span class="string">&quot;root&quot;</span></span><br><span class="line">   password := <span class="string">&quot;root&quot;</span></span><br><span class="line">   charset := <span class="string">&quot;utf8&quot;</span></span><br><span class="line">   DSN := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s:%s)/%s?charset=%s&amp;parseTime=true&quot;</span>,</span><br><span class="line">      username,</span><br><span class="line">      password,</span><br><span class="line">      host,</span><br><span class="line">      port,</span><br><span class="line">      database,</span><br><span class="line">      charset,</span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">   db, err := gorm.Open(mysql.Open(DSN), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;failed to connect database, err: &quot;</span> + err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   db.AutoMigrate(&amp;User&#123;&#125;)</span><br><span class="line">   <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取数据库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取数据库</span></span><br><span class="line">db := InitDB()</span><br><span class="line"><span class="comment">// 延迟关闭</span></span><br><span class="line">sqlDB, _ := db.DB()</span><br><span class="line"><span class="keyword">defer</span> sqlDB.Close()</span><br></pre></td></tr></table></figure>

<p>创建用户</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建用户</span></span><br><span class="line">newUser := User&#123;</span><br><span class="line">   Name:      name,</span><br><span class="line">   Telephone: telephone,</span><br><span class="line">   Password:  password,</span><br><span class="line">&#125;</span><br><span class="line">db.Create(&amp;newUser)</span><br></pre></td></tr></table></figure>

<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><p>便于显示，使用JSON返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回结果</span></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">   <span class="string">&quot;msg&quot;</span>:     <span class="string">&quot;注册成功&quot;</span>,</span><br><span class="line">   name:      name,</span><br><span class="line">   telephone: telephone,</span><br><span class="line">   password:  password,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">   <span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">   <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">   <span class="string">&quot;net/http&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">   gorm.Model</span><br><span class="line">   Name      <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(20);not null&quot;`</span></span><br><span class="line">   Telephone <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(20);not unique&quot;`</span></span><br><span class="line">   Password  <span class="type">string</span> <span class="string">`gorm:&quot;size:255;not null&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取数据库</span></span><br><span class="line">   db := InitDB()</span><br><span class="line">   <span class="comment">// 延迟关闭</span></span><br><span class="line">   sqlDB, _ := db.DB()</span><br><span class="line">   <span class="keyword">defer</span> sqlDB.Close()</span><br><span class="line"></span><br><span class="line">   ginServer := gin.Default()</span><br><span class="line">   ginServer.POST(<span class="string">&quot;/api/auth/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">      <span class="comment">// 获取参数</span></span><br><span class="line">      name := context.PostForm(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">      telephone := context.PostForm(<span class="string">&quot;telephone&quot;</span>)</span><br><span class="line">      password := context.PostForm(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">      <span class="comment">// 数据验证</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(telephone) != <span class="number">11</span> &#123;</span><br><span class="line">         context.JSON(http.StatusUnprocessableEntity, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;code&quot;</span>: <span class="number">422</span>, <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;手机号必须11位&quot;</span>,</span><br><span class="line">         &#125;)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(password) &lt; <span class="number">6</span> &#123;</span><br><span class="line">         context.JSON(http.StatusUnprocessableEntity, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;code&quot;</span>: <span class="number">422</span>, <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;密码长度不能小于6位&quot;</span>,</span><br><span class="line">         &#125;)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果名称没有传数据，给一个10位的随机字符串</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line">         name = RandomString(<span class="number">10</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      log.Print(name, telephone, password)</span><br><span class="line">      <span class="comment">// 判断手机号存在</span></span><br><span class="line">      <span class="keyword">if</span> isTelephoneExist(db, telephone) &#123;</span><br><span class="line">         context.JSON(http.StatusUnprocessableEntity, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;code&quot;</span>: <span class="number">422</span>, <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;用户已经存在&quot;</span>,</span><br><span class="line">         &#125;)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建用户</span></span><br><span class="line">      newUser := User&#123;</span><br><span class="line">         Name:      name,</span><br><span class="line">         Telephone: telephone,</span><br><span class="line">         Password:  password,</span><br><span class="line">      &#125;</span><br><span class="line">      db.Create(&amp;newUser)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//返回结果</span></span><br><span class="line">      context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">         <span class="string">&quot;msg&quot;</span>:     <span class="string">&quot;注册成功&quot;</span>,</span><br><span class="line">         name:      name,</span><br><span class="line">         telephone: telephone,</span><br><span class="line">         password:  password,</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">   &#125;)</span><br><span class="line">   ginServer.Run(<span class="string">&quot;:8082&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isTelephoneExist</span><span class="params">(db *gorm.DB, telephone <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> user User</span><br><span class="line">   db.Where(<span class="string">&quot;telephone = ?&quot;</span>, telephone).First(&amp;user)</span><br><span class="line">   <span class="keyword">if</span> user.ID != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandomString</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> letters = []<span class="type">byte</span>(<span class="string">&quot;asdfghjklQWERTYUIOPzxcvbnmasdfghjkl&quot;</span>)</span><br><span class="line">   result := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line"></span><br><span class="line">   rand.Seed(time.Now().Unix())</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> result &#123;</span><br><span class="line">      result[i] = letters[rand.Intn(<span class="built_in">len</span>(letters))]</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="type">string</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitDB</span><span class="params">()</span></span> *gorm.DB &#123;</span><br><span class="line">   host := <span class="string">&quot;localhost&quot;</span></span><br><span class="line">   port := <span class="string">&quot;3306&quot;</span></span><br><span class="line">   database := <span class="string">&quot;ginessential&quot;</span></span><br><span class="line">   username := <span class="string">&quot;root&quot;</span></span><br><span class="line">   password := <span class="string">&quot;root&quot;</span></span><br><span class="line">   charset := <span class="string">&quot;utf8&quot;</span></span><br><span class="line">   DSN := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s:%s)/%s?charset=%s&amp;parseTime=true&quot;</span>,</span><br><span class="line">      username,</span><br><span class="line">      password,</span><br><span class="line">      host,</span><br><span class="line">      port,</span><br><span class="line">      database,</span><br><span class="line">      charset,</span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">   db, err := gorm.Open(mysql.Open(DSN), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;failed to connect database, err: &quot;</span> + err.Error())</span><br><span class="line">   &#125;</span><br><span class="line">   db.AutoMigrate(&amp;User&#123;&#125;)</span><br><span class="line">   <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这只是初学的demo测试，没有进行封装分类和模板化操作。</p>
]]></content>
      <categories>
        <category>gin</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>gin</tag>
      </tags>
  </entry>
  <entry>
    <title>8-1反射</title>
    <url>/2023/04/11/8-1%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>反射让我们能在运行期探知对象的类型信息和内存结构。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>word-1</title>
    <url>/2023/07/13/word-1/</url>
    <content><![CDATA[<p>s</p>
<p>测试 是  是 是 是</p>
]]></content>
      <categories>
        <category>测试</category>
        <category>测试2</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
